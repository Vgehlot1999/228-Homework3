package edu.iastate.cs228.hw03;/**   A class of bags whose entries are stored in a chain of doubly linked nodes.       @author Vismay      linkedBag authors:   @author Frank M. Carrano   @author Timothy M. Henry    */public class DoublyLinkedBag<T> implements BagInterface<T>{	private DoublyLinkedNode firstNode;       // Reference to first node	private int numberOfEntries;	public DoublyLinkedBag()	{		firstNode = null;		numberOfEntries = 0;	} // end default constructor	public boolean add(T newEntry)	{		DoublyLinkedNode newNode = new DoublyLinkedNode(newEntry);		newNode.next = firstNode;		newNode.prev = newNode;		firstNode = newNode;		numberOfEntries++;				return true;	}	public T[] toArray()	{		@SuppressWarnings("unchecked")	      T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast	      int index = 0;	      DoublyLinkedNode currentNode = firstNode;	      while ((index < numberOfEntries) && (currentNode != null))	      {	         result[index] = currentNode.data;	         index++;	         currentNode = currentNode.next;	      } // end while	      				return result;	} // end toArray	public boolean isEmpty() 	{		if (numberOfEntries == 0)		{			return true;		}		return false;	} // end isEmpty	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	public int getFrequencyOf(T anEntry) 	{		int frequency = 0;	      int counter = 0;	      DoublyLinkedNode currentNode = firstNode;	      while ((counter < numberOfEntries) && (currentNode != null))	      {	         if (anEntry.equals(currentNode.data))	         {	            frequency++;	         } // end if	         	         counter++;	         currentNode = currentNode.next;	      } // end while			return frequency;	} // end getFrequencyOf	public boolean contains(T anEntry)	{		boolean found = false;	      DoublyLinkedNode currentNode = firstNode;	      	      while (!found && (currentNode != null))	      {	         if (anEntry.equals(currentNode.data))	         {	        	 found = true;	         }	         else	         {	            currentNode = currentNode.next;	         }	      }	      return found;	} // end contains	public void clear() 	{		while (!isEmpty())		{			remove();		}	} // end clear		private DoublyLinkedNode getReferenceTo(T anEntry)	{		boolean found = false;		DoublyLinkedNode currentNode = firstNode;				while (!found && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while     		return currentNode;	} // end getReferenceTo	public T remove()	{		T result = null;	      if (firstNode != null)	      {	         result = firstNode.data; 	         firstNode = firstNode.next; // Remove first node from chain	         numberOfEntries--;	      }	      return result;	} // end remove	public boolean remove(T anEntry) 	{		  boolean result = false;	      DoublyLinkedNode nodeN = getReferenceTo(anEntry);	      	      if (nodeN != null)	      {	         nodeN.data = firstNode.data; // Replace located entry with entry in first node	         	         firstNode = firstNode.next;  // Remove first node	         numberOfEntries--;	         	         result = true;	      }	      return false;	} // end remove	public T replace(T replacement)	{	    T rex = firstNode.data;	    firstNode.data = replacement;	    return rex;	}		public void removeEvery(T anEntry)	{		while (contains(anEntry) != false)		{			remove(anEntry);		}	}		/**	 Override the equals method of Object class so that it returns 	 true when the contents of two DoublyLinkedBags are same. Note 	 that two equal DoublyLinkedBags contain the same number of 	 entries, and each entry occurs in each DoublyLinkedBag the 	 same number of times. I.e., the elements in two do not need 	 to be in exact same location.	 	 Before checking the contents inside this method make sure 	 that the passed in object is not null, is of the same runtime 	 class, and the lengths are same. If any of these fail you can	 return false. Otherwise, you base your return results on 	 contents. (At the start you can also do the quick check if 	 both refer to the same object in memory.)	 	*/	@Override	public boolean equals(Object obj)	{		DoublyLinkedBag bag1 = new DoublyLinkedBag();		DoublyLinkedBag bag2 = (DoublyLinkedBag) obj;		DoublyLinkedBag bag3 = new DoublyLinkedBag();						DoublyLinkedNode node1 = firstNode;		DoublyLinkedNode node2 = bag2.firstNode;				for (int j = 0; j < getCurrentSize(); j++)		{			bag1.add(node1);			node1 = node1.next;		}				for (int k = 0; k < getCurrentSize(); k++)		{			bag3.add(node2);			node2 = node2.next;		}						if (bag1.getCurrentSize() != bag3.getCurrentSize()) 		{			return false;		}				DoublyLinkedNode nodeN = firstNode;				for (int i = 0; i < numberOfEntries; i++)		{			if (bag1.contains(nodeN) && bag3.contains(nodeN))			{				bag1.remove(nodeN);				bag3.remove(nodeN);				nodeN = nodeN.next;			}		}				if (bag1.isEmpty())		{			return true;		}		return false;	}		/**	 Returns String representation of the items in this bag.	 For example, it would return [A, B, C] if bag had three Strings "A", "B", and "C".	 	 @return String representation of items in this bag enclosed in square brackets, separated by comma and a single space (see example above). You can rely on the fact that items' proper toString method was implemented. In this method ONLY if you need to you can use String class's methods. Also, ONLY in this method you can use fully qualified name for StringBuffer class, and use all of its methods.	*/	@Override	public String toString()	{		//TODO		return "[]"; // this is returned in case bag is empty.	}		// A class of nodes for a chain of doubly linked nodes.	private class DoublyLinkedNode	{		private T	data;					// Entry in bag		private DoublyLinkedNode next;		// Link to next node		private DoublyLinkedNode prev;	// Link to previous node		private DoublyLinkedNode(T dataPortion)		{			this(dataPortion, null, null);			} // end constructor		private DoublyLinkedNode(T dataPortion, DoublyLinkedNode nextNode,				DoublyLinkedNode previousNode)		{			data = dataPortion;			next = nextNode;			prev = previousNode;		} // end constructor			} // end DoublyLinkedNode} // end DoublyLinkedBag